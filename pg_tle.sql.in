/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

-- complain if script is sourced in psql, rather than via CREATE EXTENSION
\echo Use "CREATE EXTENSION EXTNAME" to load this file. \quit

CREATE FUNCTION EXTSCHEMA.install_extension
(
  name text,
  version text,
  trusted bool,
  description text,
  ext text,
  requires text[] DEFAULT NULL,
  encoding text DEFAULT NULL
)
RETURNS boolean
SET search_path TO 'EXTSCHEMA'
AS 'MODULE_PATHNAME', 'pg_tle_install_extension'
LANGUAGE C;

CREATE FUNCTION EXTSCHEMA.install_update_path
(
  name text,
  fromvers text,
  tovers text,
  ext text
)
RETURNS boolean
SET search_path TO 'EXTSCHEMA'
AS 'MODULE_PATHNAME', 'pg_tle_install_update_path'
LANGUAGE C;

CREATE FUNCTION EXTSCHEMA.uninstall_extension(extname text)
RETURNS boolean
SET search_path TO 'EXTSCHEMA'
AS $_pgtleie_$
  DECLARE
    ctrpattern text;
    sqlpattern text;
    searchsql  text;
    dropsql    text;
    pgtlensp    text := 'EXTSCHEMA';
    func       text;
  BEGIN

    ctrpattern := format('%s%%.control', extname);
    sqlpattern := format('%s%%.sql', extname);
    searchsql := 'SELECT proname FROM pg_catalog.pg_proc p JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace WHERE proname LIKE $1 AND n.nspname = $2';

    FOR func IN EXECUTE searchsql USING ctrpattern, pgtlensp LOOP
      dropsql := format('DROP FUNCTION %I()', func);
      EXECUTE dropsql;
    END LOOP;

    FOR func IN EXECUTE searchsql USING sqlpattern, pgtlensp LOOP
      dropsql := format('DROP FUNCTION %I()', func);
      EXECUTE dropsql;
    END LOOP;

    RETURN true;
  END;
$_pgtleie_$
LANGUAGE plpgsql STRICT;

CREATE FUNCTION EXTSCHEMA.extension_update_paths
(
  name name,
  OUT source text,
  OUT target text,
  OUT path text
)
RETURNS SETOF RECORD
AS 'MODULE_PATHNAME', 'pg_tle_extension_update_paths'
LANGUAGE C STABLE STRICT;

CREATE FUNCTION EXTSCHEMA.available_extensions
(
  OUT name name,
  OUT default_version text,
  OUT comment text
)
RETURNS SETOF RECORD
AS 'MODULE_PATHNAME', 'pg_tle_available_extensions'
LANGUAGE C STABLE STRICT;

CREATE FUNCTION EXTSCHEMA.available_extension_versions
(
  OUT name name,
  OUT version text,
  OUT superuser boolean,
  OUT trusted boolean,
  OUT relocatable boolean,
  OUT schema name,
  OUT requires name[],
  OUT comment text
)
RETURNS SETOF RECORD
AS 'MODULE_PATHNAME', 'pg_tle_available_extension_versions'
LANGUAGE C STABLE STRICT;

-- Revoke privs from PUBLIC
REVOKE EXECUTE ON FUNCTION EXTSCHEMA.install_extension
(
  name text,
  version text,
  trusted bool,
  description text,
  ext text,
  requires text[],
  encoding text
) FROM PUBLIC;

REVOKE EXECUTE ON FUNCTION EXTSCHEMA.install_update_path
(
  name text,
  fromvers text,
  tovers text,
  ext text
) FROM PUBLIC;

REVOKE EXECUTE ON FUNCTION EXTSCHEMA.uninstall_extension
(
  extname text
) FROM PUBLIC;

DO
$_do_$
BEGIN
   IF EXISTS (
      SELECT FROM pg_catalog.pg_roles
      WHERE  rolname = 'pgtle_admin') THEN

      RAISE NOTICE 'Role "pgtle_admin" already exists. Skipping.';
   ELSE
      CREATE ROLE pgtle_admin NOLOGIN;
   END IF;
END
$_do_$;

GRANT USAGE, CREATE ON SCHEMA EXTSCHEMA TO pgtle_admin;

GRANT EXECUTE ON FUNCTION EXTSCHEMA.install_extension
(
  name text,
  version text,
  trusted bool,
  description text,
  ext text,
  requires text[],
  encoding text
) TO pgtle_admin;

GRANT EXECUTE ON FUNCTION EXTSCHEMA.install_update_path
(
  name text,
  fromvers text,
  tovers text,
  ext text
) TO pgtle_admin;

GRANT EXECUTE ON FUNCTION EXTSCHEMA.uninstall_extension
(
  extname text
) TO pgtle_admin;

DO
$_do_$
BEGIN
   IF EXISTS (
      SELECT FROM pg_catalog.pg_roles
      WHERE  rolname = 'pgtle_staff') THEN

      RAISE NOTICE 'Role "pgtle_staff" already exists. Skipping.';
   ELSE
      CREATE ROLE pgtle_staff NOLOGIN;
   END IF;
END
$_do_$;

GRANT USAGE ON SCHEMA EXTSCHEMA TO pgtle_staff;

CREATE TYPE EXTSCHEMA.pg_tle_features as ENUM ('passcheck');
CREATE TYPE EXTSCHEMA.password_types as ENUM ('PASSWORD_TYPE_PLAINTEXT', 'PASSWORD_TYPE_MD5', 'PASSWORD_TYPE_SCRAM_SHA_256');

CREATE TABLE EXTSCHEMA.feature_info(
	feature EXTSCHEMA.pg_tle_features,
	schema_name text,
	proname text,
	obj_identity text,
  PRIMARY KEY(feature, schema_name, proname));

SELECT pg_catalog.pg_extension_config_dump('EXTSCHEMA.feature_info', '');

GRANT SELECT on EXTSCHEMA.feature_info TO PUBLIC;

-- Helper function to insert into table
CREATE FUNCTION EXTSCHEMA.register_feature(proc regproc, feature EXTSCHEMA.pg_tle_features)
RETURNS VOID
LANGUAGE plpgsql
AS $$
DECLARE
pg_proc_relid oid;
proc_oid oid;
schema_name text;
nspoid oid;
proname text;
proc_schema_name text;
ident text;

BEGIN
	SELECT oid into nspoid FROM pg_catalog.pg_namespace
	where nspname = 'pg_catalog';

	SELECT oid into pg_proc_relid from pg_catalog.pg_class
	where relname = 'pg_proc' and relnamespace = nspoid;

	SELECT pg_namespace.nspname, pg_proc.oid, pg_proc.proname into proc_schema_name, proc_oid, proname FROM
	pg_catalog.pg_namespace, pg_catalog.pg_proc
	where pg_proc.oid = proc AND pg_proc.pronamespace = pg_namespace.oid;

	SELECT identity into ident FROM pg_catalog.pg_identify_object(pg_proc_relid, proc_oid, 0);

	INSERT INTO EXTSCHEMA.feature_info VALUES (feature, proc_schema_name, proname, ident);
END;
$$;

-- Helper function to delete from table
CREATE FUNCTION EXTSCHEMA.unregister_feature(proc regproc, feature EXTSCHEMA.pg_tle_features)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
	pg_proc_relid oid;
	proc_oid oid;
	schema_name text;
	nspoid oid;
	proc_name text;
	proc_schema_name text;
	ident text;
	row_count bigint;
BEGIN
	SELECT oid into nspoid
  FROM pg_catalog.pg_namespace
	WHERE nspname = 'pg_catalog';

	SELECT oid into pg_proc_relid
  FROM pg_catalog.pg_class
	WHERE
		relname = 'pg_proc' AND
		relnamespace = nspoid;

	SELECT
		pg_namespace.nspname,
		pg_proc.oid,
		pg_proc.proname
  INTO
		proc_schema_name,
		proc_oid,
		proc_name
	FROM pg_catalog.pg_namespace, pg_catalog.pg_proc
	WHERE
		pg_proc.oid = proc AND
		pg_proc.pronamespace = pg_namespace.oid;

	DELETE FROM EXTSCHEMA.feature_info
	WHERE
		feature_info.feature = $2 AND
		feature_info.schema_name = proc_schema_name AND
		feature_info.proname = proc_name;

	GET DIAGNOSTICS row_count = ROW_COUNT;

	IF ROW_COUNT = 0 THEN
    RAISE EXCEPTION 'Could not unregister "%": does not exist.', $1;
  END IF;
END;
$$;

-- Prevent function from being dropped if referenced in table
CREATE FUNCTION EXTSCHEMA.pg_tle_feature_info_sql_drop()
RETURNS event_trigger
LANGUAGE plpgsql
AS $$
DECLARE
obj RECORD;
num_rows int;

BEGIN
	FOR obj IN SELECT * FROM pg_catalog.pg_event_trigger_dropped_objects()

	LOOP
	IF tg_tag = 'DROP FUNCTION'
	THEN
		select count(*) into num_rows from EXTSCHEMA.feature_info
		where obj_identity = obj.object_identity;

		IF num_rows > 0 then
			RAISE EXCEPTION 'Function is referenced in EXTSCHEMA.feature_info';
		END IF;
	END IF;

	END LOOP;
END;
$$;

CREATE EVENT TRIGGER pg_tle_event_trigger_for_drop_function
   ON sql_drop
   EXECUTE FUNCTION EXTSCHEMA.pg_tle_feature_info_sql_drop();

REVOKE ALL ON SCHEMA EXTSCHEMA FROM PUBLIC;
GRANT USAGE ON SCHEMA EXTSCHEMA TO pgtle_staff;
