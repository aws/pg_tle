/*
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License").
 * You may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

-- complain if script is sourced in psql, rather than via CREATE EXTENSION
\echo Use "CREATE EXTENSION EXTNAME" to load this file. \quit

CREATE FUNCTION EXTSCHEMA.install_extension
(
  extname text,
  extvers text,
  ctl_str text,
  ctl_alt bool,
  sql_str text
)
RETURNS TEXT
SET search_path TO 'EXTSCHEMA'
AS 'MODULE_PATHNAME', 'bc_install_extension'
LANGUAGE C STRICT;

CREATE FUNCTION EXTSCHEMA.install_upgrade_path
(
  extname text,
  fmvers text,
  tovers text,
  sql_str text
)
RETURNS TEXT
SET search_path TO 'EXTSCHEMA'
AS 'MODULE_PATHNAME', 'bc_install_upgrade_path'
LANGUAGE C STRICT;

CREATE FUNCTION EXTSCHEMA.uninstall_extension(extname text)
RETURNS TEXT
SET search_path TO 'EXTSCHEMA'
AS $_pgbcie_$
  DECLARE
    ctrpattern text;
    sqlpattern text;
    searchsql  text;
    dropsql    text;
    pgbcnsp    text := 'EXTSCHEMA';
    func       text;
  BEGIN

    ctrpattern := format('%s%%.control', extname);
    sqlpattern := format('%s%%.sql', extname);
    searchsql := 'SELECT proname FROM pg_catalog.pg_proc p JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace WHERE proname LIKE $1 AND n.nspname = $2';

    FOR func IN EXECUTE searchsql USING ctrpattern, pgbcnsp LOOP 
      dropsql := format('DROP FUNCTION %I()', func);
      EXECUTE dropsql;
    END LOOP;

    FOR func IN EXECUTE searchsql USING sqlpattern, pgbcnsp LOOP 
      dropsql := format('DROP FUNCTION %I()', func);
      EXECUTE dropsql;
    END LOOP;

    RETURN 'OK';
  END;
$_pgbcie_$
LANGUAGE plpgsql STRICT;

CREATE FUNCTION EXTSCHEMA.extension_update_paths
(
  name name,
  OUT source text,
  OUT target text,
  OUT path text
)
RETURNS SETOF RECORD
AS 'MODULE_PATHNAME', 'bc_extension_update_paths'
LANGUAGE C STABLE STRICT;

CREATE FUNCTION EXTSCHEMA.available_extensions
(
  OUT name name,
  OUT default_version text,
  OUT comment text
)
RETURNS SETOF RECORD
AS 'MODULE_PATHNAME', 'bc_available_extensions'
LANGUAGE C STABLE STRICT;

CREATE FUNCTION EXTSCHEMA.available_extension_versions
(
  OUT name name,
  OUT version text,
  OUT superuser boolean,
  OUT trusted boolean,
  OUT relocatable boolean,
  OUT schema name,
  OUT requires name[],
  OUT comment text
)
RETURNS SETOF RECORD
AS 'MODULE_PATHNAME', 'bc_available_extension_versions'
LANGUAGE C STABLE STRICT;

-- Revoke privs from PUBLIC
REVOKE EXECUTE ON FUNCTION EXTSCHEMA.install_extension
(
  extname text,
  extvers text,
  ctr_str text,
  ctr_alt bool,
  sql_str text
) FROM PUBLIC;

REVOKE EXECUTE ON FUNCTION EXTSCHEMA.install_upgrade_path
(
  extname text,
  fmvers text,
  tovers text,
  sql_str text
) FROM PUBLIC;

REVOKE EXECUTE ON FUNCTION EXTSCHEMA.uninstall_extension
(
  extname text
) FROM PUBLIC;

DO
$_do_$
BEGIN
   IF EXISTS (
      SELECT FROM pg_catalog.pg_roles
      WHERE  rolname = 'backcountry_admin') THEN

      RAISE NOTICE 'Role "backcountry_admin" already exists. Skipping.';
   ELSE
      CREATE ROLE backcountry_admin NOLOGIN;
   END IF;
END
$_do_$;

GRANT USAGE, CREATE ON SCHEMA EXTSCHEMA TO backcountry_admin;

GRANT EXECUTE ON FUNCTION EXTSCHEMA.install_extension
(
  extname text,
  extvers text,
  ctr_str text,
  ctr_alt bool,
  sql_str text
) TO backcountry_admin;

GRANT EXECUTE ON FUNCTION EXTSCHEMA.install_upgrade_path
(
  extname text,
  fmvers text,
  tovers text,
  sql_str text
) TO backcountry_admin;

GRANT EXECUTE ON FUNCTION EXTSCHEMA.uninstall_extension
(
  extname text
) TO backcountry_admin;

DO
$_do_$
BEGIN
   IF EXISTS (
      SELECT FROM pg_catalog.pg_roles
      WHERE  rolname = 'backcountry_staff') THEN

      RAISE NOTICE 'Role "backcountry_staff" already exists. Skipping.';
   ELSE
      CREATE ROLE backcountry_staff NOLOGIN;
   END IF;
END
$_do_$;

GRANT USAGE ON SCHEMA EXTSCHEMA TO backcountry_staff;

CREATE TYPE EXTSCHEMA.bc_features as ENUM ('passcheck');
CREATE TYPE EXTSCHEMA.password_types as ENUM ('PASSWORD_TYPE_PLAINTEXT', 'PASSWORD_TYPE_MD5', 'PASSWORD_TYPE_SCRAM_SHA_256');

CREATE TABLE EXTSCHEMA.feature_info(
	feature EXTSCHEMA.bc_features,
	schema_name text,
	proname text,
	obj_identity text);

CREATE INDEX feature_info_idx ON EXTSCHEMA.feature_info(feature);

GRANT SELECT on EXTSCHEMA.feature_info TO PUBLIC;

-- Helper function to insert into table
CREATE FUNCTION EXTSCHEMA.bc_feature_info_sql_insert(proc regproc, feature EXTSCHEMA.bc_features)
RETURNS VOID
LANGUAGE plpgsql
AS $$
DECLARE
pg_proc_relid oid;
proc_oid oid;
schema_name text;
nspoid oid;
proname text;
proc_schema_name text;
ident text;

BEGIN
	SELECT oid into nspoid FROM pg_catalog.pg_namespace
	where nspname = 'pg_catalog';

	SELECT oid into pg_proc_relid from pg_catalog.pg_class
	where relname = 'pg_proc' and relnamespace = nspoid;

	SELECT pg_namespace.nspname, pg_proc.oid, pg_proc.proname into proc_schema_name, proc_oid, proname FROM
	pg_catalog.pg_namespace, pg_catalog.pg_proc
	where pg_proc.oid = proc AND pg_proc.pronamespace = pg_namespace.oid;

	SELECT identity into ident FROM pg_catalog.pg_identify_object(pg_proc_relid, proc_oid, 0);

	INSERT INTO EXTSCHEMA.feature_info VALUES (feature, proc_schema_name, proname, ident);
END;
$$;


-- Prevent function from being dropped if referenced in table
CREATE FUNCTION EXTSCHEMA.bc_feature_info_sql_drop()
RETURNS event_trigger
LANGUAGE plpgsql
AS $$
DECLARE
obj RECORD;
num_rows int;

BEGIN
	FOR obj IN SELECT * FROM pg_catalog.pg_event_trigger_dropped_objects()

	LOOP
	IF tg_tag = 'DROP FUNCTION'
	THEN
		select count(*) into num_rows from EXTSCHEMA.feature_info
		where obj_identity = obj.object_identity;

		IF num_rows > 0 then
			RAISE EXCEPTION 'Function is referenced in EXTSCHEMA.feature_info';
		END IF;
	END IF;

	END LOOP;
END;
$$;

CREATE EVENT TRIGGER bc_event_trigger_for_drop_function
   ON sql_drop
   EXECUTE FUNCTION EXTSCHEMA.bc_feature_info_sql_drop();

REVOKE ALL on SCHEMA EXTSCHEMA FROM public;
GRANT USAGE on SCHEMA EXTSCHEMA TO public;
